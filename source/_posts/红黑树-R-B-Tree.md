---
title: 红黑树(R-B Tree)
date: 2016-06-11 12:55:58
tags: [algorithm]  
categories: [技术]  
---
# 红黑树简介    
红黑树是一种<font color="red">自平衡二叉树</font>，或者说类平衡树、特殊的二叉查找树，可以在O(log n)时间内就完成查找、插入、删除等基本操作，
在统计性能上要好于平衡二叉树(AVL树)。相比普通的二叉树，它在每个节点上增加了一个存储位来表示节点的颜色(Red or Black)。
通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树可确保没有一条路径会比其他路径长出两倍，从而达到接近平衡的目的。

相比AVL树，红黑树不是高度平衡的，对树的每次修改，无需每次都rebalance，在插入新节点时顶多两次旋转，在删除节点时顶多
三次旋转，从而节省了开销，非常适合对搜索效率要求比较高，对数据修改比较频繁的场景，在C++的STL中，包括set, multiset, map, multimap等容器，
以及Linux虚拟内存的管理等都是基于红黑树实现。

<!-- more -->

红黑树首先是一棵二叉查找树，以下简单回顾一把二叉查找树。 
```
对于树中的每一个节点，如果它有左子树，则左子树中的所有节点的值都不大于该节点的值，如果有右子树，则右子树中的所有节点的值都不小于该节点的值。
根据这个性质，二叉搜索树执行查找、插入、删除等操作的时间复杂度是O(log n)，而当这颗树在最坏情况下，退化成一棵具有n个节点线性链，此时运行时间复杂度为O(n)。
```
知道二叉树在最坏场景下可能退化成线性链，增加操作时间复杂度后，红黑树就是能通过保持树的平衡来确保最坏情况不会退化成线性链，
来保证树的高度近似平衡来保证性能的，其基本的动态几何操作时间保持为O(log n)。  

# 红黑树时间复杂度分析  
红黑树的时间复杂度为: O(log n)  
定理: 一棵含有n个节点的红黑树的高度至多为2log(n+1)。  


# 红黑树性质
红黑树每个节点是一个五元组，五个域分别是：color(颜色), key(数据), left(指向左孩子指针), right(指向父孩子指针), p(指向父节点指针)。  
1. 红黑树的每个节点要么是红的，要么是黑的(非红即黑)。   
2. 根节点永远都是黑的（出生树根就是黑的）。  
3. 每个叶节点(树尾的NIL节点或NULL节点，此处的叶子节点不是一个真正的子节点，但可以理解为是一个并不真实存在的NULL节点)也是黑的（树根树叶都是黑的）。  
4. 如果一个节点是红的，则它的两个儿子都是黑的(红黑原理，不可连续两个节点为红)。   
5. 从于任意一节点到叶子节点(树尾端NIL或NULL指针)的每一条路径都包含相同数目的黑节点。  
性质4和性质5结合：假设从树根到树叶共会n个黑色节点，那么最短的一条路径可能就是有这n个纯黑节点组成，而最长的一条就是红黑交替组成的路径。
也就是说，红黑树上不会存在任何路径多余其他路径的两倍长，顶多是等于两倍。    

!["红黑树"](https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree.png?raw=true)
注: 前面所说的叶节点或NULL节点，就是图中的NIL节点，并不包含数据，只是一个充当树在此结束的指示，并不真实存在。  

二叉树的红黑性，决定了从树根到树叶的最长可能路径不会超过最短路径的两倍。  
# 树的旋转  
在对红黑树数据节点进行插入或删除操作时，可能使得树违背红黑树的性质，这时需要对该树进行旋转变化，比如修改节点颜色或者指向，以保证树的红黑性。
1. 左旋  
!["左旋"]((https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree_left.png?raw=true)
当以plvot节点为中心做左旋时，假设plvot的右孩子Y非NIL，pivot可以是树的任意左孩子，也非NIL节点。  左旋将以pivot到Y之间的链作为支轴
进行，它将使得Y成为子树新的根，而y的左左孩子b则成为pivot的右孩子(可以这样理解，以pivot为中心的链条:a->pivot->Y左滑一个位置，于是P
就链上Y了，接着pivot脱节，与P断链，垂直掉了下来，同时把正下方的b和Y的链接砸掉了，取代b自己和Y链上，最后b在下掉过程中被pivot的右支
拉住连接上。  
2. 右旋  
!["右旋"]((https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree_right.png?raw=true)
3. 双旋  
双旋只是单旋的两次应用。  

#二叉树的插入和删除  
二叉查找树插入原则: 比当前值大往右走，比当前值小往左走，插入在树枝上进行。  

二叉查找树删除技巧: 
1. 查找到需要删除的节点X。  
2. 在X的左子树中找到最大元素M或者在它的右子树中找到最小元素M，交换(M，X)。此时M节点必然至多只有一个孩子。  
3. 用M的子节点代替M节点。   
综上，二叉查找树的删除操作归结于删除一个至多只有一个孩子的节点。在删除这个节点后，用它的孩子节点替换就好了。  

# 红黑树的查找
红黑树首先是一棵二叉查找树，所以其查找操作和普通二叉查找树类似。  

红黑树的插入、删除操作会导致可能失去树的红黑性，而恢复其红黑性需要调整部分节点的颜色O(log n)和不超过三次的树的旋转操作(插入
操作最多只需两次)。


# 红黑树的插入  
红黑树的插入操作和二叉查找树一样是在树叶上进行，且插入的新节点总是红色节点。向一个含有n个节点的红黑树插入一个新节点的操作可以在O(log n)时间内完成。可概括为如下几个步骤:    
1. 查找要插入的位置，时间复杂度为: O(log n)  
2. 将新节点颜色赋值为红色  
若赋为黑色，则会导致树根到树叶的一条路径上多一个额外的黑节点，由前面的红黑树性质可知，任何路径上的黑节点数目是一致的，这样
赋为黑色节点再调整麻烦就大了。而设为红色节点，顶多导致两个连续红色节点 的冲突，这可以通过颜色调换和树的旋转操作来调整。  
3. 自下而上重新调整红黑树  

假设需要插入的节点为N，其父节点为P，其父P的兄弟节点为U，其祖父节点为G(即P和U都是G的两个子节点)。  
1. 如果P是黑色的，则整棵树无需调整。因为插入新节点后，出现连续两个黑节点或者是红黑交替都没关系。  
2. 如果P是红色的(此时祖父节点G一定是黑的)，则插入新节点N后，会违背不能连续出现红节点的性质，此时需要调整。  

(a)既然新节点的父节点P是红的，再观察下他叔叔U，若U也是红色的则:  
将P和U变为黑色，这样新插入的红色节点N就安全咯，但是红黑性质5说各个路径上的黑节点数目是一致的，P和U边黑了，那么应该将祖父节点
G变红才好，已确保各条路上的黑节点数不变，当然，祖父节点G的父节点也有可能是红的，G变红了，那么G的父节点就得变黑，即在祖父节点上需要递归调整颜色，
直到满足树的红黑性，如果恰好把根节点染成了红色，可强制调整为黑。  
!["pu_red"]((https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree_pu_red.png?raw=true)
  
(b)如果新节点的父节点P是红的，而它叔叔U为黑或者空缺，且N是右孩子，则：  
对父节点P进行一次左旋操作，如果还是有两个连续红节点，则按下面情形处理。  
!["pu_rb_r"]((https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree_pu_rb_r.png?raw=true)
 
(c)如果新节点的父节点P是红的，而它叔叔U为黑，且N是左孩子，则：  
对祖父节点G进行一次右旋操作。并交换以前父节点P和祖父节点G的颜色。以为调整后P为黑色，所以无需顾虑调整后P的父节点是否为红的情况。    
!["pu_rb_l"]((https://github.com/xixiang230/xixiang230.github.io/blob/master/images/brtree_pu_rb_l.png?raw=true)

# 红黑树的删除  
1. 如果删除的是红色节点，不破坏树的红黑性质。  
2. 如果删除的是红色节点，则这个路径上会少一个黑色节点，需要重新着色或旋转解决。  

