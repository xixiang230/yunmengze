---
title: 动态规划
date: 2016-06-26 20:09:37
tags: [动态规划]  
categories: [技术]
---
# 动态规划简介 
```
dynamic programming is a method for solving a complex proble by breaking it down into a collection of simpler subproblems.  
```
动态规划是通过将问题拆分，定义问题状态和状态直接的关系，使得问题能够以递推(分治)的方法解决。如何拆分问题，才是动态规划的
核心，而拆分问题靠的就是状态的定义和状态转义方程的定义。  
## 状态的定义  
```
给定长度为N的数列，求这个数列的最长上升(递增)子数列(LIS)的长度。以数列:[1, 7, 2, 8, 3, 4]为列，其最长递增子数列为: [1, 2, 3, 4]，
长度为4，次长的长度为3，分别为[1, 7, 8]，[1, 2, 3]。
```
要解决这个问题，首先就是要定义这个问题和这个问题的子问题。需要说明的是题目中描述的问题是字面上的问题，找不出子问题，没有
子问题，题目就无法利用动态规划求解。  
于是重新定义问题如下：  
```
给定长度为N的数列  
设F(k)为: 以数列中第k项结尾的最长递增子序列的长度  
求F(1)， F(2)，F(3)， ... F(N)中的最大值  
```
显然，新问题和原问题等价。  
而对于F(k)而言，F(1)，F(2)，F(k-1)都是F(k)的子问题，因为以第k项结尾的最长递增子序列(LIS)，包含着已第1, ... k-1中某项结尾
的LIS。上面新问题F(k)可以叫做状态，其中"F(k)为数列中第k项结尾的LIS的长度"叫做对对状态的定义。之所以把F(k)称之为"状态"而
不是"问题"，一是避免与原问题混淆，二是这个新问题是数学化定义的。  

对于状态的定义可能不止一种，设置可以是二维的，以完全不同的视角定义，比如这里，还可以这样定义:  
```
给定一个长度为N的数列，设F(i, k)为在前i项中的，长度为k的最长增长递增子序列中，最后一位的最小值。1<=k<=N。若在前i项中，
不存在长度为k的最长递增子序列，则F(i, k)为正无穷。求最大的x，使得F(N, x)不为正无穷。上述的F(i, k)就是状态，定义中的F(i, k)
为在前i项中，长度为k的最长递增子序列中，最后一位的最小值就是对状态的定义。     
```

## 状态转义方程  
定义好状态后，状态和状态之间的关系式就叫做状态转义方程。例如对应LIS问题的第一种定义  
```
设F(k)为以数列中第k项结尾的最长递增子序列的长度。   
```
设A为题中的数列，状态转移方程为: 
F(1) = 1 (根据状态定义导出边界情况)
F(k) = max(F(i) +1 | A(k) > A(i), i (- (1 .. k-1)) (k > 1)
问题解释如下:  
以第k项结尾的LIS的长度是: 保证第i项比第k项小的情况下，以第i项结尾的LIS长度加1的最大值，取遍i的所有值(i < k)。

第二种定义：  
```
设F(i, K)为数列前i项中，长度为k的递增子序列中，最后一位的最小值。
```
设A为题中数列，状态转义方程为：  
若A(i) > F(i-1, k-1)，则F(i,k) = min(A(i), F(i-1,k)
否则: F(i,k) = F(i-1,k)  
可以看错，这里的状态转义方程就是定义了问题和子问题之间的关系，可以看出，状态转移方程就是带有条件的地递推式。  

## 动态规划思考  
1. 缓存 重叠子问题 记忆化  
这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和第98项，在计算
第101项的时候，需要第100项和第99项，这时你还需要重新计算第99项吗？不需要，只要在第一个计算的时候把他记下来就可以了。
